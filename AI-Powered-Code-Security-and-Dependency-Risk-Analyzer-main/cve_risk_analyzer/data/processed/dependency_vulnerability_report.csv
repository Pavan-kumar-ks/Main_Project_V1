req_package,req_version,cve_id,cpe_vendor,cpe_product,cpe_version,cvss_base_score,severity,description,published,last_modified
ijson>,3.1.4,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
pandas>,2.0,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
pyarrow>,12.0,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
packaging>,23.0,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
python-dateutil,,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
orjson,,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
tqdm,,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
flask,2.0.1,CVE-2025-24023,dpgaspar,flask-appbuilder,*,3.7,LOW,"Flask-AppBuilder is an application development framework. Prior to 4.5.3, Flask-AppBuilder allows unauthenticated users to enumerate existing usernames by timing the response time from the server when brute forcing requests to login. This vulnerability is fixed in 4.5.3.",2025-03-03T16:15:41.820,2025-03-07T21:44:56.620
flask,2.0.1,CVE-2025-28101,dogukanurker,flaskblog,2.6.1,6.5,MEDIUM,An arbitrary file deletion vulnerability in the /post/{postTitle} component of flaskBlog v2.6.1 allows attackers to delete article titles created by other users via supplying a crafted POST request.,2025-04-17T18:15:49.637,2025-04-23T19:03:51.237
flask,2.0.1,CVE-2025-28102,dogukanurker,flaskblog,2.6.1,6.1,MEDIUM,A cross-site scripting (XSS) vulnerability in flaskBlog v2.6.1 allows attackers to execute arbitrary web scripts or HTML via a crafted payload injected into the postContent parameter at /createpost.,2025-04-21T17:15:23.710,2025-06-23T13:09:59.990
flask,2.0.1,CVE-2025-28103,dogukanurker,flaskblog,2.6.1,6.4,MEDIUM,Incorrect access control in laskBlog v2.6.1 allows attackers to arbitrarily delete user accounts via a crafted request.,2025-04-21T18:15:22.353,2025-05-28T15:49:20.930
flask,2.0.1,CVE-2025-28104,dogukanurker,flaskblog,2.6.1,9.1,CRITICAL,Incorrect access control in laskBlog v2.6.1 allows attackers to access all usernames via a crafted input.,2025-04-21T18:15:22.520,2025-05-28T15:49:14.883
flask,2.0.1,CVE-2025-32962,dpgaspar,flask-appbuilder,*,4.3,MEDIUM,"Flask-AppBuilder is an application development framework built on top of Flask. Versions prior to 4.6.2 would allow for a malicious unauthenticated actor to perform an open redirect by manipulating the Host header in HTTP requests. Flask-AppBuilder 4.6.2 introduced the `FAB_SAFE_REDIRECT_HOSTS` configuration variable, which allows administrators to explicitly define which domains are considered safe for redirection. As a workaround, use a reverse proxy to enforce trusted host headers.",2025-05-16T14:15:31.190,2025-09-19T18:04:24.427
flask,2.0.1,CVE-2025-53631,dogukanurker,flaskblog,*,5.4,MEDIUM,"flaskBlog is a blog app built with Flask. In versions 2.8.1 and prior, improper sanitization of postContent when submitting POST requests to /createpost leads to arbitrary JavaScript execution (XSS) on all pages the post is reflected on including /, /post/[ID], /admin/posts, and /user/[ID] of the user that made the post. At time of publication, there are no public patches available.",2025-08-14T16:15:36.840,2025-08-21T21:29:29.807
flask,2.0.1,CVE-2025-55734,dogukanurker,flaskblog,*,6.5,MEDIUM,"flaskBlog is a blog app built with Flask. In 2.8.0 and earlier, the code checks if the userRole is ""admin"" only when visiting the /admin page, but not when visiting its subroutes. Specifically, only the file routes/adminPanel.py checks the user role when a user is trying to access the admin page, but that control is not done for the pages routes/adminPanelComments.py and routes/adminPanelPosts.py. Thus, an unauthorized user can bypass the intended restrictions, leaking sensitive data and accessing the following pages: /admin/posts, /adminpanel/posts, /admin/comments, and /adminpanel/comments.",2025-08-19T19:15:37.450,2025-08-22T20:58:55.130
flask,2.0.1,CVE-2025-55735,dogukanurker,flaskblog,*,5.4,MEDIUM,"flaskBlog is a blog app built with Flask. In 2.8.0 and earlier, when creating a post, there's no validation of the content of the post stored in the variable ""postContent"". The vulnerability arises when displaying the content of the post using the | safe filter, that tells the engine to not escape the rendered content. This can lead to a stored XSS inside the content of the post. The code that causes the problem is in template/routes.html.",2025-08-19T19:15:37.620,2025-08-22T20:57:15.983
flask,2.0.1,CVE-2025-55736,dogukanurker,flaskblog,*,6.5,MEDIUM,"flaskBlog is a blog app built with Flask. In 2.8.0 and earlier, an arbitrary user can change his role to ""admin"", giving its relative privileges (e.g. delete users, posts, comments etc.). The problem is in the routes/adminPanelUsers file.",2025-08-19T19:15:37.837,2025-08-22T20:56:14.600
flask,2.0.1,CVE-2025-55737,dogukanurker,flaskblog,*,6.5,MEDIUM,"flaskBlog is a blog app built with Flask. In 2.8.0 and earlier, when deleting a comment, there's no validation of the ownership of the comment. Every user can delete an arbitrary comment of another user on every post, by simply intercepting the delete request and changing the commentID. The code that causes the problem is in routes/post.py.",2025-08-19T20:15:35.277,2025-08-21T18:40:41.943
flask,2.0.1,CVE-2025-58065,dpgaspar,flask-appbuilder,*,6.5,MEDIUM,"Flask-AppBuilder is an application development framework. Prior to version 4.8.1, when Flask-AppBuilder is configured to use OAuth, LDAP, or other non-database authentication methods, the password reset endpoint remains registered and accessible, despite not being displayed in the user interface. This allows an enabled user to reset their password and be able to create JWT tokens even after the user is disabled on the authentication provider. Users should upgrade to Flask-AppBuilder version 4.8.1 or later to receive a fix. If immediate upgrade is not possible, manually disable password reset routes in the application configuration; implement additional access controls at the web server or proxy level to block access to the reset my password URL; and/or monitor for suspicious password reset attempts from disabled accounts.",2025-09-11T18:15:35.170,2025-09-24T13:41:42.183
requests,2.31.0,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
numpy,1.26.0,,,,,,UNKNOWN,No known CVEs found for this dependency.,,
django,4.2.1,CVE-2025-26699,djangoproject,django,*,5.0,MEDIUM,"An issue was discovered in Django 5.1 before 5.1.7, 5.0 before 5.0.13, and 4.2 before 4.2.20. The django.utils.text.wrap() method and wordwrap template filter are subject to a potential denial-of-service attack when used with very long strings.",2025-03-06T19:15:27.683,2025-10-03T00:32:38.420
django,4.2.1,CVE-2025-27556,djangoproject,django,*,5.8,MEDIUM,"An issue was discovered in Django 5.1 before 5.1.8 and 5.0 before 5.0.14. The NFKC normalization is slow on Windows. As a consequence, django.contrib.auth.views.LoginView, django.contrib.auth.views.LogoutView, and django.views.i18n.set_language are subject to a potential denial-of-service attack via certain inputs with a very large number of Unicode characters.",2025-04-02T13:15:44.373,2025-10-03T15:34:09.950
django,4.2.1,CVE-2025-32873,djangoproject,django,*,5.3,MEDIUM,"An issue was discovered in Django 4.2 before 4.2.21, 5.1 before 5.1.9, and 5.2 before 5.2.1. The django.utils.html.strip_tags() function is vulnerable to a potential denial-of-service (slow performance) when processing inputs containing large sequences of incomplete HTML tags. The template filter striptags is also vulnerable, because it is built on top of strip_tags().",2025-05-08T04:17:18.157,2025-09-02T18:58:27.083
django,4.2.1,CVE-2025-32873,djangoproject,django,5.2,5.3,MEDIUM,"An issue was discovered in Django 4.2 before 4.2.21, 5.1 before 5.1.9, and 5.2 before 5.2.1. The django.utils.html.strip_tags() function is vulnerable to a potential denial-of-service (slow performance) when processing inputs containing large sequences of incomplete HTML tags. The template filter striptags is also vulnerable, because it is built on top of strip_tags().",2025-05-08T04:17:18.157,2025-09-02T18:58:27.083
django,4.2.1,CVE-2025-4894,calmkart,django-sso-server,*,3.7,LOW,"A vulnerability classified as problematic was found in calmkart Django-sso-server up to 057247929a94ffc358788a37ab99e391379a4d15. This vulnerability affects the function gen_rsa_keys of the file common/crypto.py. The manipulation leads to inadequate encryption strength. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. This product is using a rolling release to provide continious delivery. Therefore, no version details for affected nor updated releases are available.",2025-05-18T20:15:18.803,2025-06-05T19:39:01.520
django,4.2.1,CVE-2025-48432,djangoproject,django,*,4.0,MEDIUM,"An issue was discovered in Django 5.2 before 5.2.3, 5.1 before 5.1.11, and 4.2 before 4.2.23. Internal HTTP response logging does not escape request.path, which allows remote attackers to potentially manipulate log output via crafted URLs. This may lead to log injection or forgery when logs are viewed in terminals or processed by external systems.",2025-06-05T03:15:25.563,2025-10-15T17:47:56.647
django,4.2.1,CVE-2025-57833,djangoproject,django,*,7.1,HIGH,"An issue was discovered in Django 4.2 before 4.2.24, 5.1 before 5.1.12, and 5.2 before 5.2.6. FilteredRelation is subject to SQL injection in column aliases, using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed QuerySet.annotate() or QuerySet.alias().",2025-09-03T21:15:32.850,2025-10-20T19:27:51.120
django,4.2.1,CVE-2025-59681,djangoproject,django,*,7.1,HIGH,"An issue was discovered in Django 4.2 before 4.2.25, 5.1 before 5.1.13, and 5.2 before 5.2.7. QuerySet.annotate(), QuerySet.alias(), QuerySet.aggregate(), and QuerySet.extra() are subject to SQL injection in column aliases, when using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed to these methods (on MySQL and MariaDB).",2025-10-01T19:15:36.487,2025-10-07T14:50:04.887
django,4.2.1,CVE-2025-59682,djangoproject,django,*,3.1,LOW,"An issue was discovered in Django 4.2 before 4.2.25, 5.1 before 5.1.13, and 5.2 before 5.2.7. The django.utils.archive.extract() function, used by the ""startapp --template"" and ""startproject --template"" commands, allows partial directory traversal via an archive with file paths sharing a common prefix with the target directory.",2025-10-01T19:15:37.007,2025-10-22T15:58:29.237
